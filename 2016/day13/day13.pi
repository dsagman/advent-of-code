import planner.

main =>
    % I = 10,       % example
    % End = [7,4],  % example
    I = 1358,       % part 1
    End = [31,39],  % part 1

    print_maze(9,9,I),
    
    Start = [1,1],
    time(best_plan([Start,End,I],Plan,Cost)), % .017 sec
    printf("Answer Part 1: %w\n",Cost),

    % Part 2, reach within 50 steps
    Part2 = paths(50,Start,I).sort,
    Part2Alt = part2alt(50,Start,I),
    Error = [XY : XY in Part2, not member(XY,Part2Alt)],
    println(Error),
    Poss = possible(50,Start,I),
    PossError = [XY : XY in Error, not member(XY,Poss)],
    println(PossError),
    foreach (E in Error)
        best_plan_bin([Start,E,I],EPlan,ECost),
        println([ECost,EPlan])
    end,
    printf("Answer Part 2 Alt: %w\n",Part2Alt.len),
    printf("Answer Part 2: %w\n",Part2.len).

% do we need visited or does table take care of this?

% part2 101 is too low
% part2 108 is wrong
% part2 138 is wrong
% part2 is not 137
% part2 141 is correct

paths(Steps, Start, I) = Visited =>
    Visited = bfs(Steps, [Start],[Start], I).    

bfs(0, _Frontier, Visited, _I) = Visited.  
bfs(Steps, Frontier, Visited0, I) = VisitedFinal =>
    Next := [],
    Vacc := Visited0,

    foreach ([X,Y] in Frontier)
        foreach ([DX,DY] in [[1,0],[0,1],[-1,0],[0,-1]])
            NX = X + DX,  NY = Y + DY,
            if NX >= 0, NY >= 0 then 
                if f(NX,NY,I), not member([NX,NY], Vacc) then
                    Vacc := Vacc ++ [[NX,NY]],
                    Next := Next ++ [[NX,NY]]
                end
            end
        end
    end,
    VisitedFinal = bfs(Steps-1, Next, Vacc, I).


part2alt(Steps,Start,I) = R => 
    Poss = possible(Steps,Start,I),
    PossCopy = copy_term(Poss),
    Count = 0,
    Visited = [],
    while (Poss != [])
        if best_plan([Start,Poss.head,I],Steps,Plan,Cost) 
            then
                if Cost>50 then println([$cost,Cost,Poss.head]) end,
                Visited := (Visited ++ [Poss.head])
            end,
        NewPoss := Poss.tail,
        Poss := NewPoss,
    end,
    R = Visited.

possible(Steps,[X1,Y1],I) = R =>
    Rplus = [[X1+X,Y1+Y] : X in 0..Steps, Y in 0..Steps, X+Y<=Steps],
    Rminus = [[X1-X,Y1-Y] : X in 0..Steps, Y in 0..Steps, X+Y<=Steps, (X1-X) >=0, (Y1-Y) >=0],
    R = [[X,Y] : [X,Y] in (Rplus ++ Rminus)].


%%%%%%%%%%%%%%%%%%%%%%%
% Part 1 Stuff
%%%%%%%%%%%%%%%%%%%%%%%

final([Loc,End,_]), Loc = End => true.

action(S@[[X,Y],End,I],NextS,Action,Cost) =>
    % member(DX,-1..1), 
    % if abs(DX) = 1 
    %     then DY = 0 % no diagonal moves
    %     else member(DY,[-1,1]), % no DX,DY = 0,0    
    % end, 
    member([DX,DY],[[1,0],[0,1],[-1,0],[0,-1]]),
    NewX = X + DX, NewY = Y + DY,
    NewX >= 0, NewY >= 0,
    f(NewX,NewY,I), % no moving into a wall
    NextS = [[NewX,NewY],End,I],
    Action = [NewX,NewY],
    Cost = 1. 

% heuristic is 4x speedup
heuristic([[X,Y],[EX,EY],_]) = Dist => 
    Dist = abs(X-EX)+abs(Y-EY).

% table here is 10x speedup
table 
f(X,Y,I) => even((X*X + 3*X + 2*X*Y + Y + Y*Y + I).to_binary_string.map(to_int).sum).


print_maze(MX,MY,I) =>
    printf("  %w\n",stringify(0..MX)),
    foreach(Y in 0..MY) 
        printf("%w ",Y),
        foreach(X in 0..MX)
            if f(X,Y,I) then Wall = "." else Wall = "#" end,
            printf("%w",Wall)
        end,
        printf("\n")
    end.

stringify([]) = "".
stringify([H|T]) = to_string(H)++stringify(T).

%   0123456789
% 0 .#.####.##
% 1 ..#..#...#
% 2 #....##...
% 3 ###.#.###.
% 4 .##..#..#.
% 5 ..##....#.
% 6 #...##.###