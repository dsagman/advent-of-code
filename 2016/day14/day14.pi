% o generate keys, you first get a stream of random data by taking the MD5 of a pre-arranged salt (your puzzle input) and an increasing integer index (starting with 0, and represented in decimal); the resulting MD5 hash should be represented as a string of lowercase hexadecimal digits.

% However, not all of these MD5 hashes are keys, and you need 64 new keys for your one-time pad. A hash is a key only if:

%     It contains three of the same character in a row, like 777. Only consider the first such triplet in a hash.
%     One of the next 1000 hashes in the stream contains that same character five times in a row, like 77777.

% Considering future hashes for five-of-a-kind sequences does not cause those hashes to be skipped; instead, regardless of whether the current hash is a key, always resume testing for keys starting with the very next hash.

% For example, if the pre-arranged salt is abc:

%     The first index which produces a triple is 18, because the MD5 hash of abc18 contains ...cc38887a5.... However, index 18 does not count as a key for your one-time pad, because none of the next thousand hashes (index 19 through index 1018) contain 88888.
%     The next index which produces a triple is 39; the hash of abc39 contains eee. It is also the first key: one of the next thousand hashes (the one at index 816) contains eeeee.
%     None of the next six triples are keys, but the one after that, at index 92, is: it contains 999 and index 200 contains 99999.
%     Eventually, index 22728 meets all of the criteria to generate the 64th key.

% So, using our example salt of abc, index 22728 produces the 64th key.

% Given the actual salt in your puzzle input, what index produces your 64th one-time pad key?

import md5.
import util.

main =>
    % printf("Example: %w\n", go("abc",false)),
    printf("Part 1 Answer: %w\n", go("ihaygndm",false)).

println("Done").

go(Salt,Stretch) = R =>
    Idx = 0, PosKeys = new_map(), Keys = new_map(),
    do
        Hash = md5(Salt++Idx.to_string),
        Idx := Idx + 1,
        
        T = first_triple(Hash),
        if T != [] then put(PosKeys, Idx, T) end,

        foreach ((K = V) in PosKeys)
            if (Idx-K = 1000) del(PosKeys,K) end,
            if (Idx-K>0, has5(V,Hash)) (put(Keys,K,V), del(PosKeys,K)) end
        end

    while (Keys.size < 64),
    R = max(keys(Keys)).



first_triple([]) = []. 
first_triple([A,A,A|_]) = A.
first_triple([_|Xs]) = first_triple(Xs).

has5(_,[]) => false.
has5(A,[A,A,A,A,A|_]) => true.
has5(A,[_|Xs]) => has5(A,Xs). 