%    100  99  98  97  96  95  94  93  92  91 
%     65  64  63  62  61  60  59  58  57  90
%     66  37  36  35  34  33  32  31  56  89
%     67  38  17  16  15  14  13  30  55  88
%     68  39  18   5   4   3  12  29  54  87
%     69  40  19   6   1   2  11  28  53  86 
%     70  41  20   7   8   9  10  27  52  85
%     71  42  21  22  23  24  25  26  51  84
%     72  43  44  45  46  47  48  49  50  83
%     73  74  75  76  77  78  79  80  81  82

%     1,4,15,34,61,96
%      3,11,19,27,35 

% [0 ,  0]  1
% [1 ,  0]  2
% [1 ,  1]  3
% [0 ,  1]  4
% [-1,  1]  5
% [-1,  0]  6
% [-1, -1]  7
% [0 , -1]  8
% [1 , -1]  9
% [2 , -1] 10
% [2 ,  0] 11
% [2 ,  1] 12
% [2 ,  2] 13
% [1 ,  2] 14
% [0 ,  2] 15

%    R     U      L     D
% [[1,0],[0,1],[-1,0],[0,-1]]
import math.

main =>    
    [Part1,Part2] = go(368078),
    printf("Answer Part 1: %w\n",Part1),
    printf("Answer Part 2: %w\n",Part2).

go(N) = [P1,P2] =>
    Loc = [0,0],
    Deltas = [[1,0],[0,1],[-1,0],[0,-1]], DeltaIdx = 1,
    LocVals = new_map([[0,0]=1]), SpiralSum = 1,
    foreach(I in 1..N-1)
        Loc := addXY(Loc,Deltas[DeltaIdx]),
        DeltaIdx := ((floor(sqrt(4*I+1))+3) mod 4)+1, %https://oeis.org/A063826
        if SpiralSum <= N 
        then SpiralSum := sum([get(LocVals, Key, 0) : Key in neighbors(Loc)]),
             put(LocVals, Loc, SpiralSum),
        end,
    end,
    % println(LocVals.values.sort),
    P1 = Loc.map(abs).sum,
    P2 = SpiralSum.


addXY([X,Y],[DX,DY]) = [X+DX,Y+DY].

neighbors(Loc) = [addXY(Loc,Nbors) : Nbors in [[0,1],[1,1],[1,0],[0,-1],[-1,-1],[-1,0],[-1,1],[1,-1]]]

